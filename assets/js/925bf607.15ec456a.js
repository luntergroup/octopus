"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[333],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return f}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),f=r,g=u["".concat(s,".").concat(f)]||u[f]||d[f]||o;return n?a.createElement(g,i(i({ref:t},c),{},{components:n})):a.createElement(g,i({ref:t},c))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2107:function(e,t,n){n.r(t),n.d(t,{default:function(){return d},frontMatter:function(){return l},metadata:function(){return s},toc:function(){return p}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],l={id:"annotations",title:"Introduction"},s={unversionedId:"guides/filtering/annotations",id:"guides/filtering/annotations",isDocsHomePage:!1,title:"Introduction",description:"Octopus calls variants and genotypes using a Bayesian model. Like any model, there are some aspects of real error that are not fully captured in the model which can lead to false calls. We therefore recommended filtering calls to improve precision.",source:"@site/docs/guides/filtering/annotations.md",sourceDirName:"guides/filtering",slug:"/guides/filtering/annotations",permalink:"/octopus/docs/guides/filtering/annotations",editUrl:"https://github.com/${organizationName}/${projectName}/edit/${branch}/website/docs/guides/filtering/annotations.md",version:"current",frontMatter:{id:"annotations",title:"Introduction"},sidebar:"docs",previous:{title:"Phasing",permalink:"/octopus/docs/guides/phasing"},next:{title:"Random Forest",permalink:"/octopus/docs/guides/filtering/forest"}},p=[{value:"Annotations",id:"annotations",children:[]}],c={toc:p};function d(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Octopus calls variants and genotypes using a Bayesian model. Like any model, there are some aspects of real error that are not fully captured in the model which can lead to false calls. We therefore recommended filtering calls to improve precision."),(0,o.kt)("p",null,"There are currently two approaches available in Octopus for filtering variants:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("a",{parentName:"li",href:"/octopus/docs/guides/filtering/thresholds"},"Hard coded thresholds")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("a",{parentName:"li",href:"/octopus/docs/guides/filtering/forest"},"Random forests"))),(0,o.kt)("p",null,"Both methods use ",(0,o.kt)("a",{parentName:"p",href:"#annotations"},"annotations")," computed by Octopus."),(0,o.kt)("p",null,"The random forest approach is preferred when sufficient training data is available (e.g. typical germline and somatic calling). Hard coded thresholds are appropriate for other cases (e.g. UMI low frequency calling)."),(0,o.kt)("h2",{id:"annotations"},"Annotations"),(0,o.kt)("p",null,"Octopus provides various annotations for filtering variants. To list available annotations, use the command "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"$ octopus --help --annotations\n")),(0,o.kt)("p",null,"For example, the current annotations are:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},'Name    Kind    Number  Type    Description\nAC  FORMAT  A   Integer "Number of non-reference alleles called for each sample"    \nAD  FORMAT  R   Integer "Empirical allele depth"    \nADP FORMAT  1   Integer "Number of reads overlapping the position that could be assigned to an allele"  \nAF  FORMAT  R   Float   "Empirical allele frequency (AD / ADP)" \nAFB FORMAT  R   Float   "Absolute difference between empirical allele frequency (AF) and expected allele frequency given genotype"  \nAMQ FORMAT  R   Integer "Median mapping quality of reads assigned to each allele"   \nARF FORMAT  1   Float   "Fraction of reads overlapping the call that cannot be assigned to a unique haplotype"  \nBMC FORMAT  1   Integer "Number of base mismatches at variant position in reads supporting variant haplotype"   \nBMF FORMAT  1   Float   "Fraction of base mismatches at variant position"   \nBMQ FORMAT  1   Integer "Median quality of base mismatches in reads assigned to a unique allele"    \nBQ  FORMAT  R   Integer "Median base quality of reads supporting each allele"   \nCC  INFO    1   Float   "PP divided by QUAL"    \nCRF INFO    1   Float   "Fraction of clipped reads covering the call"   \nDAD FORMAT  R   Integer "Number of realigned reads supporting ALT alleles identified as duplicates" \nDAF FORMAT  R   Float   "Fraction of realigned reads supporting ALT alleles identified as duplicates"   \nDC  INFO    1   Float   "Number of reads supporting a de novo haplotype in the normal"  \nDENOVO  FORMAT  1   Integer "DENOVO status of each sample"  \nDP  FORMAT  1   Integer "Number of read overlapping the call"   \nDPC FORMAT  1   Float   "Concordance of allele support from duplicate reads"    \nER  FORMAT  R   Float   "Error rate in supporting reads"    \nERS FORMAT  R   Float   "Error rate standard deviation in supporting reads" \nFRF FORMAT  1   Float   "Fraction of reads filtered for calling"    \nGC  INFO    1   Float   "GC bias of the reference in a window centred on the call"  \nGQ  INFO    A   Integer "Number of non-reference alleles called for each sample"    \nGQD FORMAT  1   Float   "GQ divided by DP"  \nITV INFO    A   Flag    "Is the variant a transversion" \nMC  FORMAT  1   Integer "Number of mismatches at variant position in reads supporting variant haplotype"    \nMF  FORMAT  1   Float   "Fraction of reads with mismatches at variant position" \nMHL FORMAT  .   Integer "Mean likelihood (Phreds) of reads overlapping the site assigned to each haplotype" \nMP  INFO    1   Float   "Model posterior for this haplotype block"  \nMQ  INFO    1   Float   "Mean mapping quality of reads overlapping the call"    \nMQ0 INFO    1   Integer "Number of reads overlapping the call with mapping quality zero"    \nMQD FORMAT  1   Integer "Maximum pairwise difference in median mapping qualities of reads supporting each haplotype"    \nMRC FORMAT  1   Integer "Number of reads supporting the call that appear misaligned"    \nMRL FORMAT  1   Integer "Maximum read length overlapping the site"  \nNC  INFO    1   Float   "Fraction of overlapping reads supporting a somatic haplotype in the normal"    \nPLN FORMAT  1   Integer "Length of the phase block for the call"    \nPP  INFO    1   Float   "Call posterior probability"    \nPPD INFO    1   Float   "PP divided by DP"  \nQD  INFO    1   Float   "QUAL divided by DP"    \nQUAL    INFO    A   Integer "Number of non-reference alleles called for each sample"    \nREB FORMAT  1   Float   "Probability allele occurs at the end (head or tail) of supporting reads"   \nREFCALL FORMAT  1   Integer "REFCALL status of each sample" \nRSB FORMAT  1   Float   "Bias of variant side (head or tail half) in supporting reads"  \nRTB FORMAT  1   Float   "Probability allele occurs in the tail of supporting reads" \nSB  FORMAT  1   Float   "Strand bias of reads based on haplotype support"   \nSD  FORMAT  1   Float   "Strand bias of reads overlapping the site; probability mass in tails of Beta distribution" \nSF  FORMAT  1   Float   "Max fraction of reads supporting ALT alleles that are supplementary"   \nSHC FORMAT  1   Integer "Number of called somatic haplotypes"   \nSMQ FORMAT  1   Integer "Median mapping quality of reads assigned to called somatic haplotypes" \nSOMATIC FORMAT  1   Integer "SOMATIC status of each sample" \nSTRL    INFO    1   Integer "Length of overlapping STR" \nSTRP    INFO    1   Integer "Period of overlapping STR" \nVL  FORMAT  1   Integer "Maximum length of called alleles"\n')))}d.isMDXComponent=!0}}]);