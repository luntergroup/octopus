"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[361],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return u}});var l=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);t&&(l=l.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,l)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,l,a=function(e,t){if(null==e)return{};var n,l,a={},r=Object.keys(e);for(l=0;l<r.length;l++)n=r[l],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(l=0;l<r.length;l++)n=r[l],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=l.createContext({}),c=function(e){var t=l.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return l.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return l.createElement(l.Fragment,{},t)}},d=l.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=c(n),u=a,h=d["".concat(s,".").concat(u)]||d[u]||m[u]||r;return n?l.createElement(h,o(o({ref:t},p),{},{components:n})):l.createElement(h,o({ref:t},p))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=d;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:a,o[1]=i;for(var c=2;c<r;c++)o[c]=n[c];return l.createElement.apply(null,o)}return l.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9761:function(e,t,n){n.r(t),n.d(t,{default:function(){return m},frontMatter:function(){return i},metadata:function(){return s},toc:function(){return c}});var l=n(7462),a=n(3366),r=(n(7294),n(3905)),o=["components"],i={id:"cell",title:"Cell"},s={unversionedId:"guides/models/cell",id:"guides/models/cell",isDocsHomePage:!1,title:"Cell",description:"The cell calling model is used to call germline and somatic variants in single cell and minibatch cell sequencing data. The model attempts to infer local phylogenies for the cells and accounts for allelic biases and dropout often observed in single cell sequencing data.",source:"@site/docs/guides/models/cell.md",sourceDirName:"guides/models",slug:"/guides/models/cell",permalink:"/octopus/docs/guides/models/cell",editUrl:"https://github.com/${organizationName}/${projectName}/edit/${branch}/website/docs/guides/models/cell.md",version:"current",frontMatter:{id:"cell",title:"Cell"},sidebar:"docs",previous:{title:"Polyclone",permalink:"/octopus/docs/guides/models/polyclone"},next:{title:"Error Models",permalink:"/octopus/docs/guides/errorModels"}},c=[{value:"Usage: basic",id:"usage-basic",children:[]},{value:"Usage: with controls",id:"usage-with-controls",children:[]},{value:"Usage: with minibatchs",id:"usage-with-minibatchs",children:[]}],p={toc:c};function m(e){var t=e.components,n=(0,a.Z)(e,o);return(0,r.kt)("wrapper",(0,l.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"cell")," calling model is used to call germline and somatic variants in single cell and minibatch cell sequencing data. The model attempts to infer local phylogenies for the cells and accounts for allelic biases and dropout often observed in single cell sequencing data."),(0,r.kt)("h2",{id:"usage-basic"},"Usage: basic"),(0,r.kt)("p",null,"If all of the samples are single cells and none are control cells:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ octopus -C cell \\\n    -R ref.fa \\\n    -I cell1.bam cell2.bam ... cellN.bam \\\n    -o cells.vcf\n")),(0,r.kt)("h2",{id:"usage-with-controls"},"Usage: with controls"),(0,r.kt)("p",null,"If the experiment includes control cells (e.g. for tumour-normals) then provide the control cell sample names (",(0,r.kt)("inlineCode",{parentName:"p"},"--normal-samples"),"; ",(0,r.kt)("inlineCode",{parentName:"p"},"-N"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ octopus -C cell \\\n    -R ref.fa \\\n    -I cell1.bam cell2.bam ... cellN.bam \\\n    --normal-samples CONTROL1 CONTROL2 ... CONTROLM \\\n    -o cells.vcf\n")),(0,r.kt)("p",null,"All normal cells are assumed to originate from the root (i.e. founder) node of the phylogeny relating cells, and are therefore assumed to all have the same genotype."),(0,r.kt)("h2",{id:"usage-with-minibatchs"},"Usage: with minibatchs"),(0,r.kt)("p",null,"If any of the samples are derived from minibatches of cells then specify high dropout concentrations (",(0,r.kt)("inlineCode",{parentName:"p"},"--sample-dropout-concentration"),") for these samples:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ octopus -C cell \\\n    -R ref.fa \\\n    -I cell1.bam cell2.bam ... cellN.bam \\\n    --sample-dropout-concentration MINIBATCH1=100 MINIBATCH2=100 .. MINIBATCHM=100 \\\n    -o cells.vcf\n")),(0,r.kt)("p",null,"The argument for each minibatch sample may reflect the number of cells contained in the minibatch; the larger the number of cells, the larger the argument value."),(0,r.kt)("p",null,"The usual use for minibatch samples is for better controls, in which case the minibatches will be normal samples:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ octopus -C cell \\\n    -R ref.fa \\\n    -I cell1.bam cell2.bam ... cellN.bam \\\n    --normal-samples MINIBATCH1 MINIBATCH2 ... MINIBATCHM \\\n    --sample-dropout-concentration MINIBATCH1=100 MINIBATCH2=100 .. MINIBATCHM=100 \\\n    -o cells.vcf\n")),(0,r.kt)("h4",{id:"vcf-output"},"VCF output"),(0,r.kt)("p",null,"There are several annotations included in the VCF output:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:"center"},"INFO/FORMAT"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SOMATIC"),(0,r.kt)("td",{parentName:"tr",align:"center"},"INFO"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Indicates that a somatic mutation was inferred (i.e. the phylogeny contains more than one node).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"PY"),(0,r.kt)("td",{parentName:"tr",align:"center"},"INFO"),(0,r.kt)("td",{parentName:"tr",align:"left"},"The MAP phylogeny inferred for the variant loci. This annotation is only added for SOMATIC calls.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"PPP"),(0,r.kt)("td",{parentName:"tr",align:"center"},"INFO"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Posterior probability (Phred) for the MAP phylogeny.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"PSPP"),(0,r.kt)("td",{parentName:"tr",align:"center"},"INFO"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Posterior probabilities (Phred) that the local phylogeny contains ",(0,r.kt)("inlineCode",{parentName:"td"},"0"),",",(0,r.kt)("inlineCode",{parentName:"td"},"1"),",... nodes")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"PNAP"),(0,r.kt)("td",{parentName:"tr",align:"center"},"FORMAT"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Posterior probabilities (Phred) that this sample is assigned to node ID ",(0,r.kt)("inlineCode",{parentName:"td"},"0"),",",(0,r.kt)("inlineCode",{parentName:"td"},"1"),",.. in the MAP phylogeny (",(0,r.kt)("inlineCode",{parentName:"td"},"PY"),").")))),(0,r.kt)("h5",{id:"py-notation"},(0,r.kt)("inlineCode",{parentName:"h5"},"PY")," notation"),(0,r.kt)("p",null,"The phylogeny is serialised using the following algorithm:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"def serialise(result, node):\n    if (node != NULL):\n        result += '(' + str(node.id)\n        for child in node:\n            serialise(result, child)\n        result += ')'\n")),(0,r.kt)("p",null,"The algorithm is called with the root node of the phylogeny ",(0,r.kt)("inlineCode",{parentName:"p"},'serialise("", ROOT)'),". Examples:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"     0\n   /   \\\n  1     2\n\n(0(1)(2))\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"     0\n       \\\n        1\n         \\\n          2\n\n(0(1(2)))\n")),(0,r.kt)("h4",{id:"cnv-calling"},"CNV calling"),(0,r.kt)("p",null,"The model can try to identify local copy changes (i.e. deletions or gains of haplotypes). This will result in some samples having called genotypes with different ploidies to the default ploidy. The maximum number of gains and losses is specified with the ",(0,r.kt)("inlineCode",{parentName:"p"},"--max-copy-gain")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"--max-copy-loss")," options, respectively. For example, to identify up to one copy gain or loss:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ octopus -C cell \\\n    -R ref.fa \\\n    -I cell1.bam cell2.bam ... cellN.bam \\\n    --max-copy-gain 1 --max-copy-loss 1 \\\n    -o cells.vcf\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Warning")," calling copy gains is currently computationally very expensive."),(0,r.kt)("h4",{id:"performance-considerations"},"Performance considerations"),(0,r.kt)("p",null,"A critical parameter for this calling model is the maximum size of the phylogeny (",(0,r.kt)("inlineCode",{parentName:"p"},"--max-clones"),"). Copy loss and gain calling are also computationally expensive."),(0,r.kt)("p",null,"It is recommended to allow automatic thread usage with this calling model (use ",(0,r.kt)("inlineCode",{parentName:"p"},"--threads")," option without an argument)."))}m.isMDXComponent=!0}}]);